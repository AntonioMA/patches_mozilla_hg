# HG changeset patch
# Parent f550b112a19b9eb3ceb0eb728cef11433cdf9bf7
# User Antonio M. Amaya <amac@tid.es>

diff --git a/dom/apps/src/Webapps.jsm b/dom/apps/src/Webapps.jsm
--- a/dom/apps/src/Webapps.jsm
+++ b/dom/apps/src/Webapps.jsm
@@ -50,19 +50,19 @@ Cu.import("resource://gre/modules/Promis
 #ifdef MOZ_WIDGET_GONK
 XPCOMUtils.defineLazyGetter(this, "libcutils", function() {
   Cu.import("resource://gre/modules/systemlibs.js");
   return libcutils;
 });
 #endif
 
 function debug(aMsg) {
-#ifdef MOZ_DEBUG
+//#ifdef MOZ_DEBUG
   dump("-*- Webapps.jsm : " + aMsg + "\n");
-#endif
+//#endif
 }
 
 function getNSPRErrorCode(err) {
   return -1 * ((err) & 0xffff);
 }
 
 function supportUseCurrentProfile() {
   return Services.prefs.getBoolPref("dom.webapps.useCurrentProfile");
@@ -1220,16 +1220,17 @@ this.DOMApplicationRegistry = {
   // Webapps:Uninstall:Broadcast:Return:OK
   // Webapps:FireEvent
   // Webapps:checkForUpdate:Return:OK
   // Webapps:UpdateState
   broadcastMessage: function broadcastMessage(aMsgName, aContent) {
     if (!(aMsgName in this.children)) {
       return;
     }
+    debug("Broadcasting message: " + aMsgName + " for " + aContent.eventType);
     this.children[aMsgName].forEach(function(mmRef) {
       mmRef.mm.sendAsyncMessage(aMsgName, aContent);
     });
   },
 
   _getAppDir: function(aId) {
     return FileUtils.getDir(DIRECTORY_NAME, ["webapps", aId], true, true);
   },
@@ -2669,34 +2670,41 @@ onInstallSuccessAck: function onInstallS
       // We determine the app's 'installState' according to its previous
       // state. Cancelled download should remain as 'pending'. Successfully
       // installed apps should morph to 'updating'.
       oldApp.installState = aIsUpdate ? "updating" : "pending";
 
       // initialize the progress to 0 right now
       oldApp.progress = 0;
 
+      debug("downloadPackage: step 1");
+
       let zipFile = yield this._getPackage(requestChannel, id, oldApp, aNewApp);
+      debug("downloadPackage: step 2");
       let hash = yield this._computeFileHash(zipFile.path);
+      debug("downloadPackage: step 3");
 
       let responseStatus = requestChannel.responseStatus;
       let oldPackage = (responseStatus == 304 || hash == oldApp.packageHash);
 
       if (oldPackage) {
         debug("package's etag or hash unchanged; sending 'applied' event");
         // The package's Etag or hash has not changed.
         // We send a "applied" event right away.
         this._sendAppliedEvent(aNewApp, oldApp, id);
         return;
       }
 
+      debug("downloadPackage: step 4");
       let newManifest = yield this._openAndReadPackage(zipFile, oldApp, aNewApp,
               isLocalFileInstall, aIsUpdate, aManifest, requestChannel, hash);
 
+      debug("downloadPackage: step 5");
       AppDownloadManager.remove(aNewApp.manifestURL);
+      debug("downloadPackage: step 6");
 
       return [oldApp.id, newManifest];
 
     }).bind(this)).then(
       aOnSuccess,
       this._revertDownloadPackage.bind(this, id, oldApp, aNewApp, aIsUpdate)
     );
   },
@@ -2991,21 +2999,24 @@ onInstallSuccessAck: function onInstallS
   },
 
   _openAndReadPackage: function(aZipFile, aOldApp, aNewApp, aIsLocalFileInstall,
                                 aIsUpdate, aManifest, aRequestChannel, aHash) {
     return Task.spawn((function*() {
       let zipReader, isSigned, newManifest;
 
       try {
+        debug("Opening package " + aZipFile);
         [zipReader, isSigned] = yield this._openPackage(aZipFile, aOldApp,
                                                         aIsLocalFileInstall);
+        debug("Package opened " + aZipFile + ". Reading now!");
         newManifest = yield this._readPackage(aOldApp, aNewApp,
                 aIsLocalFileInstall, aIsUpdate, aManifest, aRequestChannel,
                 aHash, zipReader, isSigned);
+        debug("Package read " + aZipFile + ". Returning now!");
       } catch (e) {
         debug("package open/read error: " + e);
         // Something bad happened when opening/reading the package.
         // Unrecoverable error, don't bug the user.
         // Apps with installState 'pending' does not produce any
         // notification, so we are safe with its current
         // downloadAvailable state.
         if (aOldApp.installState !== "pending") {
@@ -3018,16 +3029,17 @@ onInstallSuccessAck: function onInstallS
           throw e;
         }
       } finally {
         if (zipReader) {
           zipReader.close();
         }
       }
 
+      debug("Ok, really really returning from " + aZipFile + " now!");
       return newManifest;
 
     }).bind(this));
   },
 
   _openPackage: function(aZipFile, aApp, aIsLocalFileInstall) {
     return Task.spawn((function*() {
       let certDb;
diff --git a/dom/apps/tests/test_packaged_app_update.html b/dom/apps/tests/test_packaged_app_update.html
--- a/dom/apps/tests/test_packaged_app_update.html
+++ b/dom/apps/tests/test_packaged_app_update.html
@@ -107,24 +107,39 @@ var steps = [
   },
   function() {
     PackagedTestHelper.setAppVersion(2, PackagedTestHelper.next);
   },
   function() {
     ok(true, "== TEST == Install packaged app");
     navigator.mozApps.mgmt.oninstall = function(evt) {
       ok(true, "Got oninstall event");
-      PackagedTestHelper.gApp = evt.application;
-      PackagedTestHelper.gApp.ondownloaderror = function() {
+      var app = evt.application;
+      PackagedTestHelper.gApp = app;
+      var downloaderrorHandler = function() {
         ok(false, "Download error " + PackagedTestHelper.gApp.downloadError.name);
         PackagedTestHelper.finish();
       };
-      PackagedTestHelper.gApp.ondownloadsuccess =
+      PackagedTestHelper.gApp.ondownloaderror = downloaderrorHandler;
+      var downloadsuccessHandler =
         checkLastAppState.bind(undefined, miniManifestURL, false, false,
                                2, PackagedTestHelper.next);
+      PackagedTestHelper.gApp.ondownloadsuccess = downloadsuccessHandler;
+
+      // It's possible that at this point we won't get the ondownloadsuccess
+      // or error and yet the app is installed correctly (or failed installation)
+      // already
+      if (app.downloadError && app.downloadError.name) {
+        downloaderrorHandler();
+        app.ondownloaderror = null;
+      } else if (app.installState === 'installed') {
+        ok(true, "App installed before the event was set");
+        downloadsuccessHandler();
+        app.ondownloadsuccess = null;
+      }
     };
 
     var request = navigator.mozApps.installPackage(miniManifestURL);
     request.onerror = PackagedTestHelper.mozAppsError;
     request.onsuccess = function() {
       ok(true, "Application installed");
     };
   },
