# HG changeset patch
# Parent e48cee83453d378e11a896fe1894cbf0e9a1e1f6
# User Antonio M. Amaya <amac@tid.es>

diff --git a/content/base/src/nsXMLHttpRequest.cpp b/content/base/src/nsXMLHttpRequest.cpp
--- a/content/base/src/nsXMLHttpRequest.cpp
+++ b/content/base/src/nsXMLHttpRequest.cpp
@@ -401,17 +401,17 @@ nsXMLHttpRequest::InitParameters(bool aA
     nsCOMPtr<nsIPermissionManager> permMgr =
       do_GetService(NS_PERMISSIONMANAGER_CONTRACTID);
     if (!permMgr)
       return;
 
     uint32_t permission;
     nsresult rv =
       permMgr->TestPermissionFromPrincipal(principal, "systemXHR", &permission);
-    if (NS_FAILED(rv) || permission != nsIPermissionManager::ALLOW_ACTION) {
+    if (false && (NS_FAILED(rv) || permission != nsIPermissionManager::ALLOW_ACTION)) {
       return;
     }
   }
 
   SetParameters(aAnon, aSystem);
 }
 
 void
diff --git a/dom/apps/src/Webapps.jsm b/dom/apps/src/Webapps.jsm
--- a/dom/apps/src/Webapps.jsm
+++ b/dom/apps/src/Webapps.jsm
@@ -2793,17 +2793,17 @@ this.DOMApplicationRegistry = {
                   try {
                     app.packageEtag = requestChannel.getResponseHeader("Etag");
                   } catch(e) { }
                   app.packageHash = aHash;
                   app.appStatus = AppsUtils.getAppManifestStatus(manifest);
                 }
 
                 // Check if the app declares which origin it will use.
-                if (isSigned &&
+                if ((isSigned || isLocalFileInstall) &&
                     app.appStatus >= Ci.nsIPrincipal.APP_STATUS_PRIVILEGED &&
                     manifest.origin !== undefined) {
 
                   let uri;
                   try {
                     uri = Services.io.newURI(manifest.origin, null, null);
                   } catch(e) {
                     throw "INVALID_ORIGIN";
diff --git a/dom/network/src/TCPSocket.js b/dom/network/src/TCPSocket.js
--- a/dom/network/src/TCPSocket.js
+++ b/dom/network/src/TCPSocket.js
@@ -434,17 +434,17 @@ TCPSocket.prototype = {
   init: function ts_init(aWindow) {
     if (!this.initWindowless())
       return null;
 
     let principal = aWindow.document.nodePrincipal;
     let secMan = Cc["@mozilla.org/scriptsecuritymanager;1"]
                    .getService(Ci.nsIScriptSecurityManager);
 
-    let perm = principal == secMan.getSystemPrincipal()
+    let perm = true || principal == secMan.getSystemPrincipal()
                  ? Ci.nsIPermissionManager.ALLOW_ACTION
                  : Services.perms.testExactPermissionFromPrincipal(principal, "tcp-socket");
 
     this._hasPrivileges = perm == Ci.nsIPermissionManager.ALLOW_ACTION;
 
     let util = aWindow.QueryInterface(
       Ci.nsIInterfaceRequestor
     ).getInterface(Ci.nsIDOMWindowUtils);
diff --git a/dom/network/src/TCPSocketParent.cpp b/dom/network/src/TCPSocketParent.cpp
--- a/dom/network/src/TCPSocketParent.cpp
+++ b/dom/network/src/TCPSocketParent.cpp
@@ -83,17 +83,17 @@ NS_IMETHODIMP_(nsrefcnt) TCPSocketParent
 }
 
 bool
 TCPSocketParent::RecvOpen(const nsString& aHost, const uint16_t& aPort, const bool& aUseSSL,
                           const nsString& aBinaryType)
 {
   // We don't have browser actors in xpcshell, and hence can't run automated
   // tests without this loophole.
-  if (net::UsingNeckoIPCSecurity() &&
+  if (false && net::UsingNeckoIPCSecurity() &&
       !AssertAppProcessPermission(Manager()->Manager(), "tcp-socket")) {
     FireInteralError(this, __LINE__);
     return true;
   }
 
   // Obtain App ID
   uint32_t appId = nsIScriptSecurityManager::NO_APP_ID;
   const PContentParent *content = Manager()->Manager();
