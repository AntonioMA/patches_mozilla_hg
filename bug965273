# HG changeset patch
# User Antonio M. Amaya <amac@tid.es>
# Date 1391116941 -3600
# Node ID 480f5020332219b774bf2c8396132d0b690eb778
# Parent  200a3f35f722f4f74d40cb5f2afd78a72e6f1e62
Bug 965273 - CSP: Fix serialization and deserialization and add support for the {} characters on the host name

diff --git a/content/base/src/CSPUtils.jsm b/content/base/src/CSPUtils.jsm
--- a/content/base/src/CSPUtils.jsm
+++ b/content/base/src/CSPUtils.jsm
@@ -40,17 +40,18 @@ var gETLDService = Components.classes["@
 // scheme          = <scheme production from RFC 3986>
 const R_SCHEME     = new RegExp ("([a-zA-Z0-9\\-]+)", 'i');
 const R_GETSCHEME  = new RegExp ("^" + R_SCHEME.source + "(?=\\:)", 'i');
 
 // scheme-source   = scheme ":"
 const R_SCHEMESRC  = new RegExp ("^" + R_SCHEME.source + "\\:$", 'i');
 
 // host-char       = ALPHA / DIGIT / "-"
-const R_HOSTCHAR   = new RegExp ("[a-zA-Z0-9\\-]", 'i');
+// For the app: protocol, we need to add {} to the valid character set
+const R_HOSTCHAR   = new RegExp ("[{}a-zA-Z0-9\\-]", 'i');
 
 // host            = "*" / [ "*." ] 1*host-char *( "." 1*host-char )
 const R_HOST       = new RegExp ("\\*|(((\\*\\.)?" + R_HOSTCHAR.source +
                               "+)" + "(\\." + R_HOSTCHAR.source + "+)*)", 'i');
 
 // port            = ":" ( 1*DIGIT / "*" )
 const R_PORT       = new RegExp ("(\\:([0-9]+|\\*))", 'i');
 
@@ -271,20 +272,24 @@ CSPRep.ALLOW_DIRECTIVE   = "allow";
   *        URI representing the "self" source
   * @param reportOnly (optional)
   *        whether or not this CSP is report-only (defaults to false)
   * @param docRequest (optional)
   *        request for the parent document which may need to be suspended
   *        while the policy-uri is asynchronously fetched
   * @param csp (optional)
   *        the CSP object to update once the policy has been fetched
+  * @param enforceSelfChecks (optional)
+  *        if present, and "true", will check to be sure "self" has the
+  *        appropriate values to inherit when they are omitted from the source.
   * @returns
   *        an instance of CSPRep
   */
-CSPRep.fromString = function(aStr, self, reportOnly, docRequest, csp) {
+CSPRep.fromString = function(aStr, self, reportOnly, docRequest, csp,
+                             enforceSelfChecks) {
   var SD = CSPRep.SRC_DIRECTIVES_OLD;
   var UD = CSPRep.URI_DIRECTIVES;
   var aCSPR = new CSPRep();
   aCSPR._originalText = aStr;
   aCSPR._innerWindowID = innerWindowFromRequest(docRequest);
   if (typeof reportOnly === 'undefined') reportOnly = false;
   aCSPR._reportOnlyMode = reportOnly;
 
@@ -348,28 +353,30 @@ CSPRep.fromString = function(aStr, self,
       cspWarn(aCSPR, CSPLocalizer.getStr("allowDirectiveIsDeprecated"));
       if (aCSPR._directives.hasOwnProperty(SD.DEFAULT_SRC)) {
         // Check for duplicate default-src and allow directives
         cspError(aCSPR, CSPLocalizer.getFormatStr("duplicateDirective",
                                                   [dirname]));
         CSPdebug("Skipping duplicate directive: \"" + dir + "\"");
         continue directive;
       }
-      var dv = CSPSourceList.fromString(dirvalue, aCSPR, selfUri, true);
+      var dv = CSPSourceList.fromString(dirvalue, aCSPR, selfUri,
+                                        enforceSelfChecks);
       if (dv) {
         aCSPR._directives[SD.DEFAULT_SRC] = dv;
         continue directive;
       }
     }
 
     // SOURCE DIRECTIVES ////////////////////////////////////////////////
     for each(var sdi in SD) {
       if (dirname === sdi) {
         // process dirs, and enforce that 'self' is defined.
-        var dv = CSPSourceList.fromString(dirvalue, aCSPR, selfUri, true);
+        var dv = CSPSourceList.fromString(dirvalue, aCSPR, selfUri,
+                                          enforceSelfChecks);
         if (dv) {
           aCSPR._directives[sdi] = dv;
           continue directive;
         }
       }
     }
 
     // REPORT URI ///////////////////////////////////////////////////////
@@ -513,22 +520,26 @@ CSPRep.fromString = function(aStr, self,
   *        URI representing the "self" source
   * @param reportOnly (optional)
   *        whether or not this CSP is report-only (defaults to false)
   * @param docRequest (optional)
   *        request for the parent document which may need to be suspended
   *        while the policy-uri is asynchronously fetched
   * @param csp (optional)
   *        the CSP object to update once the policy has been fetched
+  * @param enforceSelfChecks (optional)
+  *        if present, and "true", will check to be sure "self" has the
+  *        appropriate values to inherit when they are omitted from the source.
   * @returns
   *        an instance of CSPRep
   */
 // When we deprecate our original CSP implementation, we rename this to
 // CSPRep.fromString and remove the existing CSPRep.fromString above.
-CSPRep.fromStringSpecCompliant = function(aStr, self, reportOnly, docRequest, csp) {
+CSPRep.fromStringSpecCompliant = function(aStr, self, reportOnly, docRequest, csp,
+                                          enforceSelfChecks) {
   var SD = CSPRep.SRC_DIRECTIVES_NEW;
   var UD = CSPRep.URI_DIRECTIVES;
   var aCSPR = new CSPRep(true);
   aCSPR._originalText = aStr;
   aCSPR._innerWindowID = innerWindowFromRequest(docRequest);
   if (typeof reportOnly === 'undefined') reportOnly = false;
   aCSPR._reportOnlyMode = reportOnly;
 
@@ -594,17 +605,18 @@ CSPRep.fromStringSpecCompliant = functio
       CSPdebug("Skipping duplicate directive: \"" + dir + "\"");
       continue directive;
     }
 
     // SOURCE DIRECTIVES ////////////////////////////////////////////////
     for each(var sdi in SD) {
       if (dirname === sdi) {
         // process dirs, and enforce that 'self' is defined.
-        var dv = CSPSourceList.fromString(dirvalue, aCSPR, self, true);
+        var dv = CSPSourceList.fromString(dirvalue, aCSPR, self,
+                                          enforceSelfChecks);
         if (dv) {
           // Check for unsafe-inline in style-src
           if (sdi === "style-src" && dv._allowUnsafeInline) {
              aCSPR._allowInlineStyles = true;
           } else if (sdi === "script-src") {
             // Check for unsafe-inline and unsafe-eval in script-src
             if (dv._allowUnsafeInline) {
               aCSPR._allowInlineScripts = true;
@@ -1308,16 +1320,28 @@ CSPSource.fromString = function(aStr, aC
     cspError(aCSPRep, CSPLocalizer.getStr("selfDataNotProvided"));
     return null;
   }
 
   if (self && !(self instanceof CSPSource)) {
     self = CSPSource.create(self, aCSPRep, undefined, false);
   }
 
+  // check for 'unsafe-inline' (case insensitive)
+  if (aStr.toLowerCase() === "'unsafe-inline'"){
+    sObj._allowUnsafeInline = true;
+    return sObj;
+  }
+
+  // check for 'unsafe-eval' (case insensitive)
+  if (aStr.toLowerCase() === "'unsafe-eval'"){
+    sObj._allowUnsafeEval = true;
+    return sObj;
+  }
+
   // Check for scheme-source match - this only matches if the source
   // string is just a scheme with no host.
   if (R_SCHEMESRC.test(aStr)) {
     var schemeSrcMatch = R_GETSCHEME.exec(aStr);
     sObj._scheme = schemeSrcMatch[0];
     if (!sObj._host) sObj._host = CSPHost.fromString("*");
     if (!sObj._port) sObj._port = "*";
     return sObj;
@@ -1391,28 +1415,16 @@ CSPSource.fromString = function(aStr, aC
       cspError(aCSPRep, CSPLocalizer.getStr("selfKeywordNoSelfData"));
       return null;
     }
     sObj._self = self.clone();
     sObj._isSelf = true;
     return sObj;
   }
 
-  // check for 'unsafe-inline' (case insensitive)
-  if (aStr.toLowerCase() === "'unsafe-inline'"){
-    sObj._allowUnsafeInline = true;
-    return sObj;
-  }
-
-  // check for 'unsafe-eval' (case insensitive)
-  if (aStr.toLowerCase() === "'unsafe-eval'"){
-    sObj._allowUnsafeEval = true;
-    return sObj;
-  }
-
   cspError(aCSPRep, CSPLocalizer.getFormatStr("couldntParseInvalidSource",
                                               [aStr]));
   return null;
 };
 
 CSPSource.validSchemeName = function(aStr) {
   // <scheme-name>       ::= <alpha><scheme-suffix>
   // <scheme-suffix>     ::= <scheme-chr>
@@ -1472,20 +1484,20 @@ CSPSource.prototype = {
    * Generates canonical string representation of the Source.
    */
   toString:
   function() {
     if (this._isSelf)
       return this._self.toString();
 
     if (this._allowUnsafeInline)
-      return "unsafe-inline";
+      return "'unsafe-inline'";
 
     if (this._allowUnsafeEval)
-      return "unsafe-eval";
+      return "'unsafe-eval'";
 
     var s = "";
     if (this.scheme)
       s = s + this.scheme + "://";
     if (this._host)
       s = s + this._host;
     if (this.port)
       s = s + ":" + this.port;
@@ -1589,17 +1601,18 @@ this.CSPHost = function CSPHost() {
  *        string rep of a CSP Host
  * @returns
  *        an instance of CSPHost
  */
 CSPHost.fromString = function(aStr) {
   if (!aStr) return null;
 
   // host string must be LDH with dots and stars.
-  var invalidChar = aStr.match(/[^a-zA-Z0-9\-\.\*]/);
+  // We allow {} here also for app: 'hosts'
+  var invalidChar = aStr.match(/[^{}a-zA-Z0-9\-\.\*]/);
   if (invalidChar) {
     CSPdebug("Invalid character '" + invalidChar + "' in host " + aStr);
     return null;
   }
 
   var hObj = new CSPHost();
   hObj._segments = aStr.split(/\./);
   if (hObj._segments.length < 1)
@@ -1610,17 +1623,18 @@ CSPHost.fromString = function(aStr) {
     var seg = hObj._segments[i];
     if (seg == "*") {
       if (i > 0) {
         // Wildcard must be FIRST
         CSPdebug("Wildcard char located at invalid position in '" + aStr + "'");
         return null;
       }
     }
-    else if (seg.match(/[^a-zA-Z0-9\-]/)) {
+    // We allow {} here also for app: 'hosts'
+    else if (seg.match(/[^{}a-zA-Z0-9\-]/)) {
       // Non-wildcard segment must be LDH string
       CSPdebug("Invalid segment '" + seg + "' in host value");
       return null;
     }
   }
   return hObj;
 };
 
diff --git a/content/base/src/contentSecurityPolicy.js b/content/base/src/contentSecurityPolicy.js
--- a/content/base/src/contentSecurityPolicy.js
+++ b/content/base/src/contentSecurityPolicy.js
@@ -406,16 +406,28 @@ ContentSecurityPolicy.prototype = {
 /* ........ Methods .............. */
 
   /**
    * Adds a new policy to our list of policies for this CSP context.
    * @returns the count of policies.
    */
   appendPolicy:
   function csp_appendPolicy(aPolicy, selfURI, aReportOnly, aSpecCompliant) {
+    return this._appendPolicyInternal(aPolicy, selfURI, aReportOnly,
+                                      aSpecCompliant, true);
+  },
+
+  /**
+   * Adds a new policy to our list of policies for this CSP context.
+   * Only to be called from this module (not exported)
+   * @returns the count of policies.
+   */
+  _appendPolicyInternal:
+  function csp_appendPolicy(aPolicy, selfURI, aReportOnly, aSpecCompliant,
+                            aEnforceSelfChecks) {
 #ifndef MOZ_B2G
     CSPdebug("APPENDING POLICY: " + aPolicy);
     CSPdebug("            SELF: " + (selfURI ? selfURI.asciiSpec : " null"));
     CSPdebug("CSP 1.0 COMPLIANT : " + aSpecCompliant);
 #endif
 
     // For nested schemes such as view-source: make sure we are taking the
     // innermost URI to use as 'self' since that's where we will extract the
@@ -438,23 +450,25 @@ ContentSecurityPolicy.prototype = {
     // If we want to be CSP 1.0 spec compliant, use the new parser.
     // The old one will be deprecated in the future and will be
     // removed at that time.
     if (aSpecCompliant) {
       newpolicy = CSPRep.fromStringSpecCompliant(aPolicy,
                                                  selfURI,
                                                  aReportOnly,
                                                  this._weakDocRequest.get(),
-                                                 this);
+                                                 this,
+                                                 aEnforceSelfChecks);
     } else {
       newpolicy = CSPRep.fromString(aPolicy,
                                     selfURI,
                                     aReportOnly,
                                     this._weakDocRequest.get(),
-                                    this);
+                                    this,
+                                    aEnforceSelfChecks);
     }
 
     newpolicy._specCompliant = !!aSpecCompliant;
     newpolicy._isInitialized = true;
     this._policies.push(newpolicy);
     this._cache.clear(); // reset cache since effective policy changes
   },
 
@@ -945,17 +959,18 @@ ContentSecurityPolicy.prototype = {
     this._requestOrigin.QueryInterface(Ci.nsIURI);
 
     for (let pCount = aStream.read32(); pCount > 0; pCount--) {
       let polStr        = aStream.readString();
       let reportOnly    = aStream.readBoolean();
       let specCompliant = aStream.readBoolean();
       // don't need self info because when the policy is turned back into a
       // string, 'self' is replaced with the explicit source expression.
-      this.appendPolicy(polStr, null, reportOnly, specCompliant);
+      this._appendPolicyInternal(polStr, null, reportOnly, specCompliant,
+                                 false);
     }
 
     // NOTE: the document instance that's deserializing this object (via its
     // principal) should hook itself into this._principal manually.  If they
     // don't, the CSP reports will likely be blocked by nsMixedContentBlocker.
   },
 
   write:
